DDL (Data Definition Language)
데이터 구조를 생성하고 변경하고 삭제하는 명령어

1. 테이블 생성

    1) 기본형식
        Create [Temporary] Table 테이블이름(컬럼이름 자료형 [컬럼 제약 조건], ... [테이블 제약 조건])조건나열;

    2) 자료형
        숫자 : TINYINT(1Byte - true/false), INT(INTEGER), FLOAT, DOUBLE
        문자 : CHAR(길이 - 길이가 고정), VARCHAR(길이 - 길이가 가변), TEXT(긴 문자열), BLOB(파일의 내용 저장)
        날짜 : DATE(날짜), DATETIME(날짜와 시간), TIMESTAMP(날짜와 시간 - 2037년 까지 밖에 저장하지 못함), TIME(시간), YEAR(년도)
        기타 : JSON, GEOMETRY(공간 정보)

    3) 조건 나열
        ENGINE : MyISAM(Indexed Sequential Access Media - 삽입,삭제, 갱신에 불리하고, 조회에 유리함) 이나 InnoDB(삽입, 삭제, 갱신에 유리)를 설정할 수 있음
        DEFAULT CHARSET : 한글이 깨지는 경우 한글 설정하는 옵션으로 utf8을 설정해주면 되는데 MariaDB는 기본이 utf8
        auto_increament = 시작숫자 : 일련번호를 사용할 때 시작 숫자부터 시작함
        Timezone 설정 : Mac에서 사용할 때 시간 대역이 안맞아서 설정해주어야 하는 경우가 있음
        이어서

    4) 테이블 생성
        테이블 이름 : contact
        컬럼

        num - 정수

        name - 문자열이고 영문 20자까지  저장하고 자주 변경

        address - 문자열이고 영문 100자까지 저장하고 자주 변경되지 않음

        tel - 문자열로 영문 20자까지 저장하고 자주 변경됨

        email - 문자열로 영문 100자까지 저장하고 자주 변경됨

        birthday - 날짜

    

        비밀번호를 저장할 때는 대부분의 경우 해시를 수행해서 해시코드를 저장하기 때문에 해시 방법에 따라 64, 128, 256으로 설정해야 함.

        create table contact(
            num integer,
            name char(20),
            address varchar(100),
            tel char(20),
            email char(100),
            birthday date
        )ENGINE=MyISAM;
 

2. 테이블 구조 변경
    1) 기본 형식
        ALTER TABLE 테이블 이름 작업 매개변수 나열
    
    2) 테이블 구조 확인
        DESC 컬럼이름
    
    3) 컬럼 추가
        ALTER TABLE 테이블 이름 ADD 컬럼이름 자료형 제약조건;
        contact 테이블에 age라는 컬럼을 정수로 추가
        컬럼을 추가하는 경우 기존에 데이터가 존재했다면 모두 null로 삽입됨
        ALTER TABLE contact ADD age integer;
    
    4) 컬럼 삭제
        ALTER TABLE 테이블이름 DROP 컬럼이름;
        ALTER TABLE contact DROP age;
    
    5) 컬럼 변경
        이름과 자료형 변경
        ALTER TABLE 테이블이름 CHANGE 기존컬럼이름 새로운컬럼이름 자료형 제약조건;
        자료형만 변경하는 경우 - NOT NULL에 대한 설정 포함
        크기가 변경되는 경우 기존의 크기보다 커지는 것은 아무런 문제가 없지만 작아지는 것은 데이터에 손실을 발생할 수 있어 주의
        ALTER TABLE 테이블이름 MODIFY 기존컬럼이름 자료형;
        contact 테이블에서 tel 이라는 컬럼을 phone 이라는 컬럼으로 변경
        ALTER TABLE contact CHANGE tel phone varchar(11);
    
    6) 컬럼 순서 조정
        새로운 컬럼이 추가되면 맨 뒤에 추가
        컬럼을 맨 앞으로 이동
        ALTER TABLE 테이블이름 MODIFY COLUMN 컬럼이름 자료형 FIRST;
        컬럼을 특정 컬럼 뒤로 이동
        ALTER TABLE 테이블이름 MODIFY COLUMN 컬럼이름 자료형 AFTER 앞에 있을 컬럼이름;
    

    7) 테이블 이름 수정
        ALTER TABLE 원래테이블이름 RENAME 새로운테이블이름;
 

3. 테이블 삭제
    1) 기본 형식
        DROP TABLE 테이블이름;
    
    2) 테이블이 삭제가 되지 않는 경우
        외래키로 참조되는 테이블은 외래키를 소유하고 있는 테이블이 먼저 삭제되어야 함
    
    3) contact 테이블 삭제
        DROP TABLE contact;
 

4. 테이블의 모든 데이터 삭제
    TRUNCATE TABLE 테이블이름;
 

5. 테이블 압축
    CREATE TABLE 다음에 ROW_FORMAT = COMPRESSED 옵션을 추가하면 테이블을 압축해서 생성됨
    저장공간은 줄일수 있지만 작업 속도는 느려짐
    과거에는 사용했으나 현재는 잘 사용하지 않음
 

6. 주석 설정
    COMMENT ON TABLE 테이블이름 IS '주석';
 

7. 제약조건(Constraint)

    1) 무결성 제약 조건
        Entity Intergrity (개체 무결성) : 기본키는 NULL 이거나 중복될 수 없음
        Referential Integrity (참조 무결성) : 외래키는 참조할 수 있는 값이나 NULL을 가져야 함
        Domain Integrity (도메인 무결성) : 속성의 값은 정해진 도메인의 값을 가져야 함

    2) NOT NULL
        NULL 일 수 없다라는 제약 조건
        필수 입력
        컬럼의 크기와 관련이 있기 때문에 컬럼을 만들 때 제약 조건을 설정해야 함
        테이블 제약조건으로 만들 수 없음
        컬럼이름 자료형 NOT NULL 의 형태로 설정
        기본은 NULL을 허용하는 것
        
        CREATE TABLE tNullable(
            name CHAR(10) NOT NULL,
            age INTEGER
        );

        INSERT INTO tNullable(name, age) values('itoriginal', 29);
        INSERT INTO tNullable(name) values('adam');
        INSERT INTO tNullable(age) values(29); -- ERROR : name은 필수

    3) DEFAULT
        데이터베이스 이론에서는 DEFAULT는 제약조건이 아님
        입력하지 않았을 때 기본적으로 삽입되는 데이터
        DEFAULT 값의 형태로 지정
        숫자는 0 문자열의 경우는 "이나 'N/A' 등을 많이 설정하고 날짜의 경우는 현재 시간(CURRENT_TIMESTAMP 나 NOW 등)을 많이 사용
    
    4) CHECK
        값의 종류나 범위를 제한하기 위한 제약조건
        
        설정방법
            CHECK(컬럼이름 조건);
            GENDER 컬럼은 문자 3자인데 남 또는 여만 가져야 하는 경우
            GENDER CHAR(3) CHECK(GENDER IN('남', '여'))
            SCORE 컬럼은 정수인데 0 ~ 100까지의 값만 가져야 하는 경우
            SCORE INTEGER CHECK(SCORE BETWEEN 0 AND 100)

    5) PRIMARY KEY (기본키)
        테이블에서 PRIMARY KEY는 한 번만 설정 가능
        2개 이상의 컬럼으로 PRIMARY KEY(복합키)를 설정하는 경우는 테이블 제약조건으로 설정해야함
        학습할 때는 복합키를 거의 사용하지 않지만 실무에서 복합키를 사용하는 경우가 종종 발생 함
    
        MEMBER 테이블에서 ID를 PRIMARY KEY로 설정
        #컬럼 제약 조건으로 설정
        CREATE TABLE MEMBER(
            ID VARCHAR(50) PRIMARY KEY
        );

        #테이블 제약 조건으로 설정
        CREATE TABLE MEMBER(
            ID VARCHAR(50),
            PRIMARY KEY(ID)
        );
        MEMBER 테이블에서 ID 와 NAME 합쳐서 PRIMARY KEY로 설정
        #PRIMARY KEY 1번만 사용할 수 있음
        CREATE TABLE MEMBER(
            ID VARCHAR(50),
            NAME VARCHAR(50),
            ...
            PRIMARY KEY(ID, NAME)
        );

        PRIMARY KEY는 자동으로 클러스터 인덱스(저장순서대로 만들어지는 인덱스 - 하나만 생성)를 생성
        PRIMARY KEY를 이용해서 조회할 때 가장 빠른 성능을 나타 냄
        PRIMARY KEY를 설정하는 것은 중요한 작업 중의 하나임
        PRIMARY KEY는 NOT NULL 이고 UNIQUE
        
    6) UNIQUE
        중복 값을 가질수 없도록 하는 제약 조건
        NULL을 허용
        인덱스를 생성하는데 PRIMARY KEY가 없으면 UNIQUE가 클러스터 인덱스가 되고 PRIMARY KEY가 있으면 보조 인덱스가 됨
        PRIMARY KEY와 더불어 다른 테이블에서의 FOREIGN KEY가 될 수 있음
        시험에서는 PRIMARY KEY 만 FOREIGN KEY가 될 수 있다고 함

    7) 제약조건 이름 설정
        제약조건을 설정할 때 앞에 CONSTRAINT 제약조건이름을 추가하면 제약조건 이름이 생성 됨
        일반적으로 테이블 이름과 제약조건의 약자를 조합해서 만드는 경우가 많음
            PRIMARY KEY - pk
            NOT NULL - nn
            UNIQUE - uk
            CHECK - ck
            FOREIGN KEY - fk
            CREATE TABLE MEMBER(
                ID VARCHAR(50),
                NAME VARCHAR(50),
                ...
                CONSTRAINT member_pk PRIMARY KEY(ID, NAME) -- _형태의 표기 : 스네이크 표기법
            );

    8) 제약조건 수정
        
        제약조건 수정
            ALTER TABLE 테이블이름 MODIFY 컬럼이름 자료형[CONSTAINT 이름] 제약조건;
        
        제약조건 추가
            ALTER TABLE 테이블이름 ADD[CONSTAINT 이름] 제약조건(컬럼이름);
            NOT NULL을 추가로 설정하는 경우는 제약조건을 추가하는 것이 아니고 컬럼의 자료형을 수정하는 것임
        
        제약조건 삭제
            ALTER TABLE 테이블이름 DROP CONSTAINT 제약조건이름;
    
    9) Sequence(일련번호)
        컬럼 이름 뒤에 AUTO_INCREMENT 를 설정하면 일련번호가 만들어 짐
        AUTO_INCREMENT가 설정된 컬럼은 값을 대입하지 않아도 됨
        테이블을 생성할 때 초기 값을 설정할 수 있음
        일련번호 초기값 수정
        ALTER TABLE 테이블이름 AUTO_INCREMENT = 값;
        AUTO_INCREMENT는 PK나 UK를 설정해야하고 테이블에서 한 번만 설정 가능 함

    10) 참조 무결성
        tEmployee 테이블과 tProject 라는 테이블 생성
        tEmployee 테이블은 직원에 대한 정보를 가진 테이블
        tProject 테이블은 직원이 수행한 프로젝트에 대한 정보를 가진 테이블
        FOREIGN KEY를 설정하지 않은 경우

        CREATE TABLE tEmployee(
            name VARCHAR(20) PRIMARY KEY,
            salary INTEGER NOT NULL,
            addr CHAR(100) NOT NULL
        );

        INSERT INTO tEmployee(name, salary, addr)
        VALUES('김부장', 7000, '제주');

        INSERT INTO tEmployee(name, salary, addr)
        VALUES('강과장', 5000, '서울');

        INSERT INTO tEmployee(name, salary, addr)
        VALUES('박사원', 3000, '경기');

        CREATE TABLE tProject(
            projectid INTEGER AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(20),
            project VARCHAR(50),
            cost INTEGER
        );

    INSERT INTO tProject (name, project, cost) VALUES('김부장', 'KB', 5000);
    INSERT INTO tProject (name, project, cost) VALUES('강과장', 'KB', 5000);
    INSERT INTO tProject (name, project, cost) VALUES('NULL', 'KB', 5000);
    INSERT INTO tProject (name, project, cost) VALUES('이대리', 'KB', 5000);
    -- 이대리는 tEmployee 테이블에 존재하지 않지만 외래키가 설정되지 않았으므로 삽입이 가능함
    -- 이러한 구조로 테이블을 만들게 되면 tProject 테이블에 데이터를 삽입할 때마다 name을 확인해서 삽입해야 함

    tProject를 삭제

    11) 외래키 설정
    => 외래키는 상대방 테이블에서 Primary key나 unique 제약 조건이 설정되어 있어야 한다.

    컬럼제약 조건으로 설정
        컬럼이름 자료형 []


    12) 외래키 옵션
    => 옵션없이 Foreign key를 설정하게 되면 외래키로 참조되는 데이터는 삭제할 수 없다.
    => 참조 되지 않는 데이터는 삭제가 가능합니다.
    => 외래키에 의해서 참조되는 테이블은 먼저 삭제할 수 없고 외래키를 소유하고 있는 테이블을 삭제한 후 삭제를 해야 한다.

    => 조이는 참조되지 않고 있기 때문에 삭제가 가능하지만 수지는 참조 되어지고 있기 때문에 삭제가 불가능
        - DELETE FROM tEmployee WHERE name = '조이';
        - DELETE FROM tEmployee WHERE name = '수지';

    => 외래키 설정할 때 옵션
        - ON DELETE [NO ACTION | CASCADE | SET NULL | SET DEFAULT]
        - ON UPDATE [NO ACTION | CASCADE | SET NULL | SET DEFAULT]

        -> NO ACTION : 아무것도 하지 않음
        -> CASCADE : 같이 삭제되거나 같이 수정됨
        -> SET NULL : NULL로 변경
        -> SET DEFAULT : DEFAULT 값으로 변경

        -> ON UPDATE는 잘 사용하지 않는데 이유는 일반적으로 PRIMARY KEY는 불변의 성격을 갖기 때문이다.

        -> 외래키를 설정할 때 SET NULL을 지정해보자.
            CREATE TABLE tProject(
                projectid INTEGER AUTO_INCREMENT PRIMARY KEY,
                name VARCHAR(20) REFERENCE tEmployee(name) ON DELETE SET NULL,
                project VARCHAR(50),
                cost INTEGER
            );

            INSERT INTO tProject (name, project, cost) VALUES('아이린', 'KB', 5000);
            INSERT INTO tProject (name, project, cost) VALUES('수지', 'KB', 5000);
            INSERT INTO tProject (name, project, cost) VALUES('NULL', 'KB', 5000);
  
** DML과 Transaction
1. DML( Data Manipolation Language)
=> 데이터를 테이블에 삽입, 삭제 갱신하는 SQL
=> 개발자가 주로 사용하는 언어

2. 데이터 삽입

    1) 기본형식
        => INSERT INTO 테이블이름(컬럼이름 나열) VALUES(값 나열);
        => 컬럼이름을 생략하면 모든 컬럼의 값을 테이블을 만들 때 사용했던 순서대로 값에 대해 입력해야 한다.

        -> tCity 테이블에 데이터 삽입해보기
            
            - DESC tiCity; -> 구조확인
            - INSERT INTO tCity(name, area, popu, metro, region) VALUES('목포', 100, 22, 'n', '전라');
            또는
            INSERT INTO tCity VALUES ('마산', 200, 45, 'n', '경상');
            과 같이 입력 가능.

    2) NULL 삽입 기본값이 없는 경우에는 컬럼이름을 생략하고 삽입한다. 
        => 기본값이 없는 경우에는 컬럼이름을 생략하고 삽입
            - INSERT INTO DEPT (DEPTNO, DNAME) VALUES (70, '영업');

        => 명시적으로 값을 NULL
            - INSERT INTO DEPT (DEPTNO, DNAME, LOC) VALUES (80, '비서', NULL);

        => 문자열의 경우는 ""형태로 입력해도 NULL로 간주하는 DB가 있으나 MairaDB에서는 NULL이 아니고 공백으로 처리된다.
            -INSERT INTO DEPT (DEPTNO, DNAME, LOC) VALUES (80, '비서', '');
        
    3) 여러개의 데이터를 한꺼번에 삽입
        => INSERT INTO 테이블이름(컬럼이름 나열) VALUES(값 나열), (값 나열), (값 나열), (값 나열)....;
        => 학습시에는 종종 하지만, 대부분의 경우에는 드물다.

        -> INSERT INTO DEPT (DEPTNO, DNAME, LOC) VALUES (100, '홍보', NULL), (120, '마케팅', NULL);

    4) 다른 테이블로 부터 조회해서 삽입
        => INSERT INTO 테이블이름(컬럼이름 나열) SELECT 구문;

    5) 조회한 결과를 가지고 테이블 생성
        => CREATE TABLE 테이블 이름 AS SELECT 구문;

    6) 에러 무시하고 삽입
        => 스크립트 이용시 중간에 에러가 발생해도 데이터를 삽입하고자 할 떼 INSERT IGNORE INTO 구문을 이용하면 된다.

3. 데이터 삭제 

    1) 기본 형식 
        => DELETE FROM 테이블이름 [WHERE 조건];
        => WHERE 절을 생략하면 테이블의 모든 데이터가 삭제
        => TURNCATE와 유사하지만 다른점은 DELETE는 트랜잭션 설정시 복구가 가능하다.

        -> DEPT 테이블에서 DEPTNO가 40보다 큰 데이터를 전부 삭제
            
            - DELETE FROM DEPT WHERE DEPTNO > 40;
        
        => INSERT는 성공하면 반드시 1개 이상의 행이 영향을 받지만 DELETE 나 UPDATE는 0개 이상의 행이 영향을 받는다.
        => WHERE 절이 있기 때문에 조건에 맞는 데이터가 없으면 영향을 받는 행의 개수는 0이다.
        => 실패한 것이 아니다.
        => 외래키 옵션 없이 생성되면 삭제가 되지 않을 수 도 있다.

4. 데이터 수정

    1) 기본 형식
        => UPDATE 테이블이름 SET 수정할 컬럼 = 값,.. [WHERE 조건];

            -> WHERE 절을 생략하면 모든 데이터가 수정될 수 있다.
            -> tCity 테이블의 name이 서울인 데이터의 popu는 1000으로 region은 전라로 수정
                - UPDATE tCity SET popu = 1000, region = '전라' WHERE name = '서울';

        => INSERT는 성공하면 반드시 1개 이상의 행이 영향을 받지만 DELETE 나 UPDATE는 0개 이상의 행이 영향을 받는다.
        => WHERE 절이 있기 때문에 조건에 맞는 데이터가 없으면 영향을 받는 행의 개수는 0이다.
        => 실패한 것이 아니다.

5. Transaction
    => 한 번에 수행되어야 하는 논리적인 작업의 단위를 일컫는다.
    => 한개 이상의 DML 문장으로 구성된다.

    -> A와 B가 SWORD 라는 아이템을 10000원에 거래 데이터베이스에서는 하나씩 작업을 수행.
        - A유저에게서 SWORD를 삭제
        - B유저에게 SWORD를 추가
        - A 유저에게 10000원 추가
        - B 유저에게 10000을 삭제

    1) 트랙잭션이 가져야 하는 성질
        => Atomicity(원자성) : ALL or NOTHING -> 전부 수행되거나 전부 수행되지 않아야 한다.
        => Consistency(일관성) : 트랜잭션 수행 전과 수행 후의 결과가 일관성이 있어야 한다.
        => Isolation(고립성) : 하나의 트랜잭션은 다른 트랜잭션의 영향을 받으면 안되고 독립적으로 수행되어야 한다.
        => Durability(영속성) : 한 번 완료된 트랜잭션은 영원히 반영되어야 한다.

    2) 트랜잭션 구현의 원리
        => DML 작업을 수행할 때는 원본 데이터에 작업을 수행하는 것이 아니고 임시 작업 영역을 만들어서 그 영역에 데이터를 복제해서 작업을 수행한다.
        => 작업을 전부 완료하면 원본에 변경된 내역을 반영하는데 이 작업을 COMMIT 이라 한다.
        => 작업을 수행하는 도중 실패 했다면 변경내역을 원본에 반영하지 않는데 이를 ROLLBACK 이라고 한다.

    3) 트랜잭션 명령어
        => COMMIT : 원본에 반영
        
        => ROLLBACK : 원본에 반영하지 않는 것
        
        => SAVEPOINT : ROLLBACK 할 위치를 설정
        
    4) 트랜잭션 모드
        => Manual
            - 사용자가 직접 COMMIT과 ROLLBACK을 하도록 하는 모드
            - 일반적으로는 Manual을 사용한다. 

        => Auto
            - 하나의 명령어가 성공적으로 수행되면 자동으로 COMMIT을 하는 모드
            - 프로그래밍 언어에서 데이터베이스를 연결하거나 접속도구 등에서 DB 서버에 접속해서 작업을 수행하는 경우 AUTO로 설정되는 경우가 있다.
            - 이렇게 되면 commit이나 rollback이 의미가 없음.