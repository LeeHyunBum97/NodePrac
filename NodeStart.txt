Node.js

1. 개요
    => 애플리케이션을 개발할 수 있는 JS환경, 원래 JS는 브라우저 내에서 동적인 작업을 처리하기 위한 언어
       <실제 내부 코드는 C++>

    1) 장점
        => JS 엔진을 사용하기 때문에 접근이 쉬움 - Learning Curve가 짧음
        => 비동기 방식으로 리소스가 사용량이 적음
        => 다양한 라이브러리를 제공한다

    2) 단점
        => Native 언어로 만든 서버환경보다는 느릴 수 있음
        => 짧은 시간에 대량의 클라이언트 요청을 대응하는 웹 애플리케이션 개발에 적합하고 대량의 데이터를 조회하고 긴 처리 시간을 요구하는 작업에
        는 부적합하다.

        => 위와 같은 단점을 해결하기 위해 대용량 연산작업이 요구될 때는 직접 구현하지 않고 AWS의 Lamda나 Google Cloud Fucntions 같은 서비스를
        이용하기도 한다. < CPU 개수를 늘려서 사용한다고 생각 >

    3) 웹 서버 이외의 노드
        => SPA(single page application) : Angular, React, Vue 등
        => 모바일 앱 프레임 워크 : React Native
        => 데스크톱 애플리케이션 : Electron(Atom, slack, VSCode, 블록체인 애플리케이션 등)

    4) 외부 라이브러리 활용
        => npm이라는 프로그램을 이용
        => npm을 이용하면 기능을 확장한 수 많으 모듈을 쉽게 다운로드 설치 가능, 최근에는 yarn을 사용하는 경우도 많다.

2. Node 설정 및 실행 (npm init)
    1) node 프로젝트를 설치할 디렉터리 명과 같으면 안됨 -> 배포가 안된다.
    2) version 설정
    3) description: 앱에 대한 설명
    4) entry point : 프로젝트 진입점 < App.js, index.js >
    5) test command : 앱을 태스트할 때 사용할 명령어 이름
    5) git repository : 연결할 git 주소
    6) keywords : 배포시 검색되게 할 검색어_필요없음 enter
    7) author : 제작자_선택
    8) license : ISC, MIT ---> Open source 라는 의미로 ISC일 때, 사용하는 것은 괜찮으나 고쳐쓰면 알림을 주어야함, MIT는 그냥 써라

    => npm 파일명은 entry point 지정파일 실행 , node 파일명 -> 해당 파일 실행

3. 프로젝트 생성 및 실행

    1) 빈 디렉터리에서 npm init 이라는 명령어 옵션을 설정하면 된다.
        => 프로젝트를 생성하는데 성공하면 프로젝트 설정 파일인 package.json파일이 생성되고 옵션이 설정되어 있습니다.
        => 옵션은 package.json에서 변경 가능

    2) 프로젝트 실행 
        => 프로젝트 실행 : npm start, package.json에서 설정한 entry point파일이 실행 된다.
        => 특정 파일만 실행 : node 파일경로
        => 학습할 때는 파일을 실행, 프로젝트 할 때는 프로젝트 실행

    3) console.log()
        => 콘솔에 메시지를 출력하는 함수인데, 해당 결과는 터미널에 출력된다 -> 브라우저에서 실행되는 것이 아님

3. 모듈 프로그래밍
    => module : 독립적으로 실행가능한 작업의단위
    => Node에서는 하나의 파일이 모듈
    => 모듈화는 중요한 작업중의 하나, 하나의 모듈에 모든 내용을 작성하면 가독성, 재사용성이 떨어진다.
       기능별로 나누는 작업이 중요함.

    Controller : 클라이언트의 요청을 받아서 필요한 서비스 로직을 호출하고 응답을 클라이언트에게 전송하는 역할

    Service : 사용자의 로직(Business Logic)을 처리하는 역할

    Repository(DAO-Data Access Object) : 데이터 저장소와 연결해서 작업을 수행하는 역할
                                         => 과거에는 대부분 RDBMS를 사용해서 DAO라는 표현을 많이 사용, NoSQL이나 분산저장소 같은 형태가 많아
                                            짐에 따라 표현도 조금씩 상이함

    DTO(Data Trancfer Object) : 서로 다른 계층 사이에 전달을 위한 역할 < Controller, Service, Repository 계층간 >
    VO(Variable Object) : 여러개의 속성을 묶어서 하나로 표현하기 위한 역할
    Entitiy : ORM(객체와 테이블의 행을 매핑시켜주는 프레임 워크)에서 테이블과 연결되는 역할.
    ==> 3개를 묶어서 도메인(업무)클래스라고 표현하기도 함.
    ==> 앞선 Controller, Repository는 개발자가 정하지만, 도메인 클래스, 도메인 지식(비지니스 로직)은 아니다.
    ==> 도메인 클래스와 지식은 의뢰인, 기획자 등이 정하게 된다.

    view - 화면 출력하는 역할
    [Service, Repository, DTO, VO, Entitiy를 합쳐서 모델이라해서 Controller, view와 합쳐 MVC패턴이라고 한다.]

4. Node 내장 객체
    => node가 제공하는 객체
    
    1) global 객체
        => 이 객체는 노드 프로그램 전체에서 1개만 생성, 노드의 전역 객체 
        => 하나만 만들어서 노드 프로그램 전체가 공유
        => 사용하는 것을 권장하지 않지만 모든 곳에서 사용해야할 데이터가 있는 경우 사용
        --> (코레일 앱에서 구정이나 사람이 몰릴 때, 대기자 수 표시<누가봐도 같은 데이터> 비슷한 예로 백신 접종 대기자)
        --> (현재 접속자 수, 대기자 수, 로고 등은 모든 사용자에게 동일하게 보여짐 --> 이런데이터를 global을 사용)
        --> Ex> global.countUser = 10; 하며 어디서든 global.countUser를 부르면 10의 값을 가진다

    2) console 객체
        => 현재 보여지는 터미널 화면
           console.log(메시지)   --> 메시지 로깅
          
           console.error(메시지) --> 에러 형태로 로깅
           
           console.trace(메시지) --> 호출 스택을 로깅 --> 함수나 메서드를 호출하는 순서를 역순으로 출력
                                 ==> 호출하는 메서드의 순서를 확인하고자 할 때 사용
           
           console.table(배열)   --> 테이블 형태로 출력
           
           console.time(메시지) & console.timeEnd(메시지) 에서 동일한 메시지를 사용하면 2개 호출 사이 시간을 출력한다.
           
           console.dir(객체, 옵션) --> 객체를 로깅할 때 옵션을 설정하는 것이 가능
        => 로직이 복잡해지거나 여러 모듈을 거쳐가면서 수행되는 코드가 있다면 중간 중간 로그를 출력해서 확인하는 것이 좋으며
           로그를 출력하는 작업들은 배포시 모두 제거해야하고 필요하다면 로그는 파일이나 DB에 기록하는 것이 좋다.

    3) 경로 관련 속성[객체 아님]

        __filename : 현재 파일의 경로
        __dirname : 현재 디렉터리의 경로
        ==> 최근에 등자아하는 언어나 프레임워크는 _를 이용해 예약어를 만드는 경우가 많으므로 이제는 사용자 정의 이름을 만들 대 _로 시작하는
            이름을 사용하는 것을 추천하지 않습니다.

    4) module.exports
        => 모듈의 내용을 다른 곳에서 사용할 수 있도록 하고자 할 때 사용하는 속성
           module.exports = 내보낼 내용;
           exports.내보내고자하는 이름 = 내용;
           -- 두가지 방법
    
    5) this
        => 함수나 클래스 외부에서는 module.exports
        => 함수 안에서는 global
        => 클래스의 메서드 안에서는 인스턴스

    6) require 함수
        => 외부 모듈의 내용을 가져 올 때 사용하는 함수
        => import도 외부 모듈을 가져오는데 사용할 수 있지만 require과의 차이점은 require은 caching 하고 있다는 것이다.
        => 한 번 사용한 모듈을 메모리에 적재해 두었다가 다음에 require하게 되면 캐싱된 모듈을 가져온다
           .js를 생략할 수 있게 된다.

    7) process 객체
        => 노드 프로세스에 대한 정보를 가진 객체로 노드의 버전이나 CPU사용량 등을 확인할 수 있는 속성과 메서드를 제공한다.
        => process.nextTick(콜백함수) : 다른 콜백함수 보다 우선시 처리
           Promise.resolve().then() 으로 작성가능
        => process.exit(코드) : 노드 프로세스 종료 Server에서 사용하지 않는 것이 일반적이며 일반 애플리케이션을 만들었을 때
                                코드는 운영체제에게 알려주는 종료된 이유
    
    8) os 객체
        => OS에 대한 정보를 가잔 객체로 OS종류나 CPU 또는 메모리 사용량등을 확인할 수 있는 속성과 메서드를 제공한다.
        => 실제 서비스를 운영할 때는 메모리 사용량은 화인해보는 것이 좋다.
           서버를 운영할 때 메모리 사용량을 주기적으로 모니터링해서 서버를 물리적으로 늘릴 것인지 여부를 판단.
           경로 지정시 이 속성을 이용해서 지정해야 윈도우나 Mac에서 코드 수정없이 동작하는 애플리케이션을 만들 수 있다.

    9) path 객체
        => 디렉터리와 파일의 경로를 쉽게 조작하도록 도와주는 모듈 , 속성과 함수로 구분
        => path.sep :  경로 구분자(windows는 \ 나저지는 /)'
        => path.dirname(경로): 경로에 해당하는 파일이 위치하고 있는 디렉토리
        => path.extname(경로) : 경로에 해당하는 파일의 확장자
        = path.join(경로의 나열) : 경로를 합쳐서 하나의 경로를 반환
        
        const path = require("path");
        // 현재 디렉터리 확인
        console.log(__dirname);

        // 현재 디렉터리 내의 public 디렉토리 경로확인
        console.log(path.join(__dirname, "public"));

P.S : 소스코드 -> 컴파일(번역-소스코드를 이해할 수 있는 코드로 변경_문법체크) -> Build(실행이 가능한 코드로 변경_start up 코드를 삽입하고
      모듈간의 관계를 설정 (Ex> Export/Import 등의 순서)) -> Run(실행)

      소스코드가 변경되면 컴파일 -> 빌드를 다시해야 한다, 빌드를 하다보면 예기치 않은 문제가 발생할 수 있음
      ==> CI/CD, Jenkins, Cloud(웹 기반 APP)를 하는 이유 중에 하나

    10) url 모듈
        => url과 관련된 모듈
        parse 함수 : url을 분해
        format 함수 : 분해된 url을 하나로 복원

        const url = require("url");
        const addr = "https://www.naver.com/login?id=hb9397";
        const p = url.parse(addr);
        console.log(p);

        ==> Url {
                protocol: 'https:',
                slashes: true,
                auth: null,
                host: 'www.naver.com',
                port: null,
                hostname: 'www.naver.com',
                hash: null,
                search: '?id=hb9397', 
                query: 'id=hb9397',  ===> query string을 저장하고 있다.
                pathname: '/login',  ===> 서버 URL을 제외한 경로를 가지고 있다.
                path: '/login?id=hb9397', 
                href: 'https://www.naver.com/login?id=hb9397'
                } 
        ==> p.query와 같이 속성으로 하나의 값만 추출가능
    
    11) searchParams 모듈
        => query string(parameter 라고 하는데 C가 S에게 GET 방식으로 요청할 때 전송하는 데이터)을 위한 모듈
      
        => 읽어오는 함수.
        getAll(key) : key에 해당되는 모든 데이터를 가져온다. (체크박스나 파일의 경우 다중 선택이 가능)
        get(key) : key에 해당하는 데이터 1개만 가져온다. (체크박스나 파일이 아니라면 하나의 값만 전달)

        => 파라미터를 추가하는 함수
        append(key, value) : 추가
        set(key, value) : 수정

    12) util 모듈
        => 여러가지 편의 기능을 모아둔 모듈
        => util.promisifiy : 콜백 패턴을 Promise 패턴으로 변경해준다.

    13) worker_threads 모듈
        => html5에서 Web Worker라는 스레드 관련 API가 추가됨.
           이를 쉽게 사용하게 해주는 모델

        => node는 14버전까지는 싱글스레드 기반 - 하나의 스레드만 만들어서 사용자의 요청을 순서대로 처리했음
           14버전 이후 부터 멀티 스레드 지원
           --> express 모듈로 웹 서버를 만들면 멀티 스레드 형식으로 요청을 처리해준다.

    14) child_process 모듈
        => 다른 프로세스(명령어) 모델을 실행하는 모듈
           이 모듈을 사용하게 되면 운영체제 별로 분기를 해서 명령어를 처리해야 한다. --> 같은 역할을 하는 것이지만 os마다 다르기 때문

5. 모듈이지만 중요한 암호화 모듈들
    => crypto 모듈을 암호화에 하용
    
    1) 암호화 방식(암호화된 문장을 다이제스트라고 표현함.)
       
       단방향 암호화 : 암호화는 가능하지만 암호화된 문장을 이용해서 복호화 하는 것은 불가능하지만 원본 데이터와 비교는 가능하다.
                      동일한 문장을 암호화하면 동일한 결과를 만들기 때문이다.
                      
                      해시기법 : 문자열을 고정된 길이의 다른 문자열로 만드는 방식  --> 주로 사용한다.
                      
                      알고리즘으로는 md5, sha1, sha256, sha512 등이 사용되는데 md5와 sha1은 취약점이 발견되서 거의 사용하지 않는데
                      안드로이드에서 가끔 sha1 알고리즘을 사용한다.
                      블록체인에서는 sha256을 사용하다가 sha512로 변환 중이다. 

                      주로 비밀번호를 저장이나 블록체인에서는 단방향 암호화를 주로 이용한다. --> User의 정보를 서버관리자가 알 수 없게

                      createHash(알고리즘): 사용할 알고리즘 설정
                      update(문자열): 변환할 문자열을 설정
                      digest(인코딩 방식): 인코딩할 알고리즘 선택 주로 base64를 사용한다.

                      const crypto = require("crypto");

                      let password = '1234';

                      // 단방향 암호화 수행
                      let p1 = crypto
                        .createHash("sha256")
                        .update(password)
                        .digest('base64');
                      ==> 암호화 될 문장의 길이와 상관없이 암호화된 문장의 길이는 같다.

       
       양방향 암호화 : 암호화 할 때 key를 사용해서 암호화 하는 방식으로 복호화 할 수 있는데 암호화 할 때 사용한 키와 복호화 할 때 사용한
                      키가 같아야만 복호화가 가능하다.
                      동일한 데이터를 암호화 했을 때 암호화된 결과가 다를 수 있다.
                      이 데이터는 비교연산을 잘 하지 않고 복원해서 사용하는 경우가 많다.
                        
                      주로 일반 데이터 암호화에 이용한다. -> 주민등록번호, 이메일, 전화번호
                      <https / http 가 자동으로 통신간에 이를 해준다.>

                      createCipheriv(알고리즘, 키, 초기화벡터) : 양방향 암호화 객체 생성
                      암호화객체.update(암호화할 문자열, 문자열 인코딩 방식 - utf8, 인코딩 방식 - base64) : 문자열이 반환된다.
                      암호화객체.final(출력 인코딩 방식) : 암호화가 완료됨

                      createDecipheriv(알고리즘, 키, 초기화 벡터) : 양방향 복호화 객체 생성 - 암호화할 때사용한 것을 그대로 대입
                      복호화객체.update(암호화할 문자열, 인코딩 방식 - base64, 문자열 인코딩 방식 - utf8) : 문자열이 반환된다.
                      복호화객체.final(출력 인코딩 방식) : 복호화가 완료됨

                      // 암호화된 모듈 가져오기, 다른 파일이면 우선 모듈부터 가져옴
                      // const crypto = require("crypto");

                      const alg = "aes-256-cbc";

                      // node의 crypto 모듈에서는 key는 32자리 iv는 16자리
                      const key = "12345678901234567890123456789012";
                      const iv = "1234567890123456";

                      // 암호화 객체 생성
                      const cipher = crypto.createCipheriv(alg, key, iv);
                      let result = cipher.update('01033189397', 'utf-8', 'base64');
                      result += cipher.final('base64');
                      console.log(result);
            
6. 파일 시스템
    => 파일 읽고 쓰기
    => 파일을 읽고 쓰기 위한 모듈은 fs
    
    1) 파일읽기
       
       fs.readFile('파일경로', [options], 콜백함수) : 비동기 방식으로 읽음
       콜백함수는 매개변수가 두개인데 첫번째 매개변수는 에러가 발생했을 때 에러 내용을 가지고 있고 두번째 매개변수가 읽기에 성공했을 때
       읽어낸 데이터

       fs.readFileSync('파일경로', [options]) : 동기식으로 읽어내고 읽어낸 데이터를 반환

    2) Buffer
        
        => buffer: 데이터를 저장하기 위한 메모리
        => buffering: 데이터를 한꺼번에 처리하기 위해서 데이터를 모으는 작업
        => readFile 이라는 함수는 읽어내고 난 후 Buffer 객체를 반환한다.
        => Buffer 객체에는 크기를 알려주는 length 속성 그리고 문자열을 Buffer로 변경하는 from 함수나 Buffer의 내용을 문자열로 변환하는 
           toString 함수 등이 있다.

    3) 변경 가능하거나 변하지 않는 중요한 문자열은 파일이나 DB에 저장해 읽는 방식을 사용해야한다.
       => 운영환경과 개발환경이 다른 경우 소스코드 수정 시 컴파일, 빌드 과정을 다시 해야한다.
          let dataBaseUrl = "127.163.0.30

       => 파일에 기록 -> 소스코드에서 파일의 내용을 읽는 방식이 다르다
       => 클라이언트에 배포하는 프로그램을 만든 경우라면 대부분 언어는 역어셈블익이 가능하다.

*** 연습문제 :: 이전에 양방향 암호화할 때 사용했던 key와 iv값을 텍스트 파일에 저장하고 이를 읽어서 적용하는 형태로 변경

    4) Stream
        => 데이터의 흐름
        => 데이터를 일정한 크기로 잘라서 여러번에 나눠서 처리
           용량이 큰 파일을 한 번에 읽어내려고 하면 버퍼의 크기가 너무 커져서 메모리 부담이 생기게 됨 
           이렇게 작게 잘라서 처리하는 것을 chunk라고 한다, 보통 로그 파일을 읽을 때 이런 방식을 사용한다.
        => 스트리밍 : 일정한 크기의 데이터를 지속적으로 전달하는 작업
        
        => fs 모듈의 createReadStream 메서드나 createWriteStream 메서드를 이용해서 스트림을 생성
           -> 파일경로와 highWaterMark 옵션을 이용해 버퍼의 크기를 설정

        => 읽기 스트림의 경우는 data(하나의 버퍼를 읽었을 때 발생), end(읽기가 끝났을 때 발생), err(오류 발생) 이벤트를 처리한다.
        => 쓰기 스트림의 경우 drain(한부분 완료), finish(모두 완료), error 이벤트를 처리한다.

        => 스트림을 이용한 읽기

    5) 기타 함수
        => access(경로, 옵션, 콜백): 디렉토리나 파일에 접근할 수 있는지 확인
        => mkdir(경로, 콜백): 경로를 생성
        => open(경로, 옵션, 콜백): 경로의 파일을 열고 아이디를 반환하는데 파일이 없으면 생성
        => rename(기존경로, 새경로, 콜백): 이름 변경
        => unlink(경로, 콜백): 파일 지우기
        => rmdir(경로, 콜백): 디렉토리 제거
    위의 함수들은 콜백시 에러 객체를 넘겨 받는다, 에러 객체가 존재하면 에러가 발생한 것이고 그렇지 안으면 에러가 발생하지 않은 것.

7. ThreadPool
    => pool : 만들어서 모아놓은 것
    => pool은 서버에서 사용 
    => server : 요청을 처리하고 응답을 전하는 쪽, 속도나 효율을 중요시 자주 사용되는 것들은 미리 만들어두고 사용을 바로 할 수 있도록 한다
    => client : 요청을 전송하고 응답을 출력하는 쪽, 신뢰성이나 가용성을 중요시 메모리 효율을 높여야 하기 때문에 사용하기 전에 만드는 것을
                권장한다.