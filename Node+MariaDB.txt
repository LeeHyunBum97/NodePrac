1. 프로그래밍 언어에서 관계형 데이터 베이스르르 사용하는 방법
    => DB제조 업체에서 제공하는 드라이버를 사용하거나 SQL Mapper Framwork를 사용하는 방식.
        -> SQL을 이용한다.
        -> 사용하기 쉬워서 SI 같은 많은 인력이 진행하는 프로젝트에서 주로 사용한다. 

    => ORM Framework 이용
        -> SQL을 이용하지 않고 객체지향 언어의 메서드를 이용해서 SQL을 자동 변환해서 수행하는 방식
        -> 사용하기 어려우나 성능이 우수하기 때문에 적은 인력을 가지고 만드는 솔루션 분야에서 많이 이용한다.

2. 데이터베이스 제공업체에서 제공하는 드라이버를 이용해서 SQL을 실행하는 방법
    => Node에서 MariaDB는 MySQL과 같은 DB로 취급한다.

3. MariaDB 연동준비
    => 필요한 모듈 : mysql
    => 필요한 정보
        -> 연결할 DB를 소유하고 있는 컴퓨터의 IP나 도메일, 포트번호 <localhost(127.0.0.1, ::1):3306>
        -> 외부 접속 허용시 localhost가 접속이 안될 수 도 있다, 그럴 때는 루프백(127.0.0.1)으로 접속 시도.(외부의 데이터만 받을 수 있다).
        
        -> 사용할 DB 이름(sid 라고 하기도 한다.)
            - adam DB 사용 (DBeaver 에서 use adam;) _ 꼭 해야하나?

        -> DB에 대한 계정(ID/PW) _ 무조건 필요하진 않다(SQL LITE - 핸드폰 켠 순간 로그인 되었다고 판단 _ OS 인증).

    => 연결(Nod File에서)
        // 모듈가져 오기
        const mariadb = require('mysql');

        // 접속정보 가져오기
        let connection = mariadb.createConnetion({
            host : 'IP나 도메인",
            port : '포트번호',
            user : '아이디',
            password : '비밀번호',
            database : 'DB이름'
        });

        // 연결
        connection.connect(function(error){
            if(error){
                에러가 발생했을 때 수행할 내용
            }
        });
        DB 연결이 되었을 때 수행할 내용

    => 연결확인
        - Node 프토젝트 생성
        - mysql 패키지 설치 npm install mysql
        - 이후 실행

        connection.connect(function(error){
            if(error){
                console.log(error);
            } else {
                console.log(connection);
            }
        });
        // connection이 출력되면 연결 성공

4. SQL 실행 
    1) SELECT가 아닌 구문
        => 결과가 성공과 실패 또는 영향 받은 개수의 형태
        => 연결객체.query(SQL, [파라미터 배열]);
        => 파라미터 배열은 SQL을 작성할 때 값의 자리에 직접 값을 작성하지 않고 ?로 설정한 후 나중에 값을 대입할 수 있습니다.
            - "insert into Table(num, name) values(?, ?)", [1, '강감찬']
            - 프로그래밍 언어에서 SQL을 작성할 때는 ;을 하지 않는다.

            // 테이블 생성 구문
            connection.query('create Table family(id int auto_increment primary key, name varchar(20))');

            // 데이터 삽입 구문
            connection.query('insert into family(name) values(?)', '강감찬');
            connection.query('insert into family(name) values(?)', '을지문덕');
            connection.query('insert into family(name) values(?)', '이순신');

    2) SELECT 구문
        => 조회한 결과(Cursor 또는 하나의 객체나 배열)
        => SELECT 구문은 콜백함수를 매개변수로 추가하는데 콜백함수의 매개변수가 3개로 첫번째는 에러객체 두번쩨는 검색된 내용인데 JS형태로 제공되고 
           세번째는 meta data로 검색된 결과에 대한 정보입니다.
           화면에 출력할거라면 java script 객체를 그대로 이용하면 되고 데이터 형태로 제공하고자 하면 JSON 문자열로 변환하면 된다.

        => app.js 파일에서 접속에 성공했을 때 부분에 데이터를 읽어오는 코드

5. 테이블 1개를 SQL을 이용해서 연동 (NodePracDay4-Index.js)
    
    0) 기능 
        => 테이블의 데이터 전체를 가져오기
        => 테이블의 데이터 일부분을 가져오기(페이지 단위로 가져오기)
        => 기본키를 이용해서 데이터 1개 가져오기
        => 데이터 삽입, 삭제, 갱신
        => 파일 업로드와 다운로드
        
        => 가장 최근에 데이터를 수정한 시간을 기록하고 조회
            => 서버와 클라이언트 사이의 데이터 교환
            - 접속할 때 마다 서버의 데이터를 가져와서 출력
            - 서버의 데이터를 클라이언트에 저장하고 접속할 때마다 서버의 데이터와 클라이언트의 데이터를 비교해서 수정이 발생했을 때만 업데이트
                -> 서버의 데이터와 클라이언트 데이터를 비교할 수 있어야 된다.
                -> 가장 쉬운 방법은 양쪽에서 수정한 시간을 기록한 후 클라이언트 수정 시간이 서버의 수정 시간보다 이전이면 업데이트를 수행한다.
         
    1) 샘플 데이터 생성 (DB 스크립트에서 실행)

        # 테이블 생성
        CREATE TABLE goods(
        itemid int,
        itemname VARCHAR(100), 
        price int,
        description VARCHAR(200), 
        pictureurl VARCHAR(100),
        updatedate varchar(20),
        PRIMARY KEY (itemid)
        )engine=InnoDB DEFAULT CHARSET=utf8;

        insert into goods values(1, '레몬', 500,'비타민 C가 풍부한 쓴귤', 'lemon.jpg', '2020-08-01');
        insert into goods values(2, '오렌지', 1500, '비타민 C가 풍부한 당귤', 'orange.jpg', '2020-08-01');
        insert into goods values(3, '키위', 2000, '비타민 C가 풍부한 다래', 'kiwi.jpg', '2020-08-01');
        insert into goods values(4, '포도', 1000, '항상화 성분과 당분이 높고 무기물이 많은 과일', 'grape.jpg', '2020-08-01'); 
        insert into goods values(5, '딸기', 2000, '수분함량이 높은 과일', 'strawberry.jpg', '2020-08-01');
        insert into goods values(6, '무화과', 300, '칼슘, 섬유질 및 항산화 물질을 많이 함유된 식물', 'fig.jpg', '2020-08-01');
        insert into goods values(7, '레몬', 500,'비타민 C가 풍부한 쓴귤', 'lemon.jpg', '2020-08-01');
        insert into goods values(8, '오렌지', 1500, '비타민 C가 풍부한 당귤', 'orange.jpg', '2020-08-01');
        insert into goods values(9, '키위', 2000, '비타민 C가 풍부한 다래', 'kiwi.jpg', '2020-08-01');
        insert into goods values(10, '포도', 1000, '항상화 성분과 당분이 높고 무기물이 많은 과일', 'grape.jpg', '2020-08-01'); 
        insert into goods values(11, '딸기', 2000, '수분함량이 높은 과일', 'strawberry.jpg', '2020-08-01');
        insert into goods values(12, '무화과', 300, '칼슘, 섬유질 및 항산화 물질을 많이 함유된 식물', 'fig.jpg', '2020-08-01');
        insert into goods values(13, '레몬', 500,'비타민 C가 풍부한 쓴귤', 'lemon.jpg', '2020-08-01');
        insert into goods values(14, '오렌지', 1500, '비타민 C가 풍부한 당귤', 'orange.jpg', '2020-08-01');
        insert into goods values(15, '키위', 2000, '비타민 C가 풍부한 다래', 'kiwi.jpg', '2020-08-01');
        insert into goods values(16, '포도', 1000, '항상화 성분과 당분이 높고 무기물이 많은 과일', 'grape.jpg', '2020-08-01'); 
        insert into goods values(17, '딸기', 2000, '수분함량이 높은 과일', 'strawberry.jpg', '2020-08-01');
        insert into goods values(18, '무화과', 300, '칼슘, 섬유질 및 항산화 물질을 많이 함유된 식물', 'fig.jpg', '2020-08-01');
        insert into goods values(19, '딸기', 2000, '수분함량이 높은 과일', 'strawberry.jpg', '2020-08-01');
        insert into goods values(20, '무화과', 300, '칼슘, 섬유질 및 항산화 물질을 많이 함유된 식물', 'fig.jpg', '2020-08-01');
        insert into goods values(21, '레몬', 500,'비타민 C가 풍부한 쓴귤', 'lemon.jpg', '2020-08-01');
        insert into goods values(22, '오렌지', 1500, '비타민 C가 풍부한 당귤', 'orange.jpg', '2020-08-01');
        insert into goods values(23, '키위', 2000, '비타민 C가 풍부한 다래', 'kiwi.jpg', '2020-08-01');
        insert into goods values(24, '포도', 1000, '항상화 성분과 당분이 높고 무기물이 많은 과일', 'grape.jpg', '2020-08-01'); 
        insert into goods values(25, '딸기', 2000, '수분함량이 높은 과일', 'strawberry.jpg', '2020-08-01');
        insert into goods values(26, '무화과', 300, '칼슘, 섬유질 및 항산화 물질을 많이 함유된 식물', 'fig.jpg', '2020-08-01');
        insert into goods values(27, '레몬', 500,'비타민 C가 풍부한 쓴귤', 'lemon.jpg', '2020-08-01');
        insert into goods values(28, '오렌지', 1500, '비타민 C가 풍부한 당귤', 'orange.jpg', '2020-08-01');
        insert into goods values(29, '키위', 2000, '비타민 C가 풍부한 다래', 'kiwi.jpg', '2020-08-01');
        insert into goods values(30, '포도', 1000, '항상화 성분과 당분이 높고 무기물이 많은 과일', 'grape.jpg', '2020-08-01'); 

        commit;
        
        # 데이터 확인
        select * from goods;

    2) 필요한 모듈 설치
        => express : 웹 서버 모듈
        => morgan : 로그 기록을 위한 모듈
        => file-stream-rotator : 로그를 파일에 기록하기 위한 모듈
        => multer : 파일 업로드 처리를 위한 모듈
        => mysql : mysql이나 mariadb를 사용하기 위한 모듈
        => cookie-parser : 쿠키를 사용하기 위한 모듈
        => express-session : 세션을 사용하기 위한 모듈
        => express-mysql-session : 세션을 mysql이나 mariadb에 저장하기 위한 모듈
        => dotenv :.env 파일의 내용을 process.env로 저장해서 사용하기 위한 모듈
        => compresstion : 서버가 처리한 결과를 압축해서 클라이언트에게 전송하기 위한 모듈

    3) 개발 모드로 설치
        => npm install --save=dev nodemon
        => nodemon : 소스코드르르 수정하면 자동으로 재시작할 수 있도록 해주모듈
        => package.json파일의 Script 부분에 "start":"nodemon.app"을 추가 -> npm start 명령을 사용하면 nodemon app 이라는 명령이 수행되어
           entry point

    4) 서버의 데이터 업데이트 시간을 기록할 update.txt 파일을 프로젝트에 만든다