1. 프로그래밍 언어에서 관계형 데이터 베이스르르 사용하는 방법
    => DB제조 업체에서 제공하는 드라이버를 사용하거나 SQL Mapper Framwork를 사용하는 방식.
        -> SQL을 이용한다.
        -> 사용하기 쉬워서 SI 같은 많은 인력이 진행하는 프로젝트에서 주로 사용한다. 

    => ORM Framework 이용
        -> SQL을 이용하지 않고 객체지향 언어의 메서드를 이용해서 SQL을 자동 변환해서 수행하는 방식
        -> 사용하기 어려우나 성능이 우수하기 때문에 적은 인력을 가지고 만드는 솔루션 분야에서 많이 이용한다.

2. 데이터베이스 제공업체에서 제공하는 드라이버를 이용해서 SQL을 실행하는 방법
    => Node에서 MariaDB는 MySQL과 같은 DB로 취급한다.

3. MariaDB 연동준비
    => 필요한 모듈 : mysql
    => 필요한 정보
        -> 연결할 DB를 소유하고 있는 컴퓨터의 IP나 도메일, 포트번호 <localhost(127.0.0.1, ::1):3306>
        -> 외부 접속 허용시 localhost가 접속이 안될 수 도 있다, 그럴 때는 루프백(127.0.0.1)으로 접속 시도.(외부의 데이터만 받을 수 있다).
        
        -> 사용할 DB 이름(sid 라고 하기도 한다.)
            - adam DB 사용 (DBeaver 에서 use adam;) _ 꼭 해야하나?

        -> DB에 대한 계정(ID/PW) _ 무조건 필요하진 않다(SQL LITE - 핸드폰 켠 순간 로그인 되었다고 판단 _ OS 인증).

    => 연결(Nod File에서)
        // 모듈가져 오기
        const mariadb = require('mysql');

        // 접속정보 가져오기
        let connection = mariadb.createConnetion({
            host : 'IP나 도메인",
            port : '포트번호',
            user : '아이디',
            password : '비밀번호',
            database : 'DB이름'
        });

        // 연결
        connection.connect(function(error){
            if(error){
                에러가 발생했을 때 수행할 내용
            }
        });
        DB 연결이 되었을 때 수행할 내용

    => 연결확인
        - Node 프토젝트 생성
        - mysql 패키지 설치 npm install mysql
        - 이후 실행

        connection.connect(function(error){
            if(error){
                console.log(error);
            } else {
                console.log(connection);
            }
        });
        // connection이 출력되면 연결 성공

4. SQL 실행 
    1) SELECT가 아닌 구문
        => 결과가 성공과 실패 또는 영향 받은 개수의 형태
        => 연결객체.query(SQL, [파라미터 배열]);
        => 파라미터 배열은 SQL을 작성할 때 값의 자리에 직접 값을 작성하지 않고 ?로 설정한 후 나중에 값을 대입할 수 있습니다.
            - "insert into Table(num, name) values(?, ?)", [1, '강감찬']
            - 프로그래밍 언어에서 SQL을 작성할 때는 ;을 하지 않는다.

            // 테이블 생성 구문
            connection.query('create Table family(id int auto_increment primary key, name varchar(20))');

            // 데이터 삽입 구문
            connection.query('insert into family(name) values(?)', '강감찬');
            connection.query('insert into family(name) values(?)', '을지문덕');
            connection.query('insert into family(name) values(?)', '이순신');

    2) SELECT 구문
        => 조회한 결과(Cursor 또는 하나의 객체나 배열)
        => SELECT 구문은 콜백함수를 매개변수로 추가하는데 콜백함수의 매개변수가 3개로 첫번째는 에러객체 두번쩨는 검색된 내용인데 JS형태로 제공되고 
           세번째는 meta data로 검색된 결과에 대한 정보입니다.
           화면에 출력할거라면 java script 객체를 그대로 이용하면 되고 데이터 형태로 제공하고자 하면 JSON 문자열로 변환하면 된다.

        => app.js 파일에서 접속에 성공했을 때 부분에 데이터를 읽어오는 코드

5. 테이블 1개를 SQL을 이용해서 연동 (NodePracDay4-Index.js)
    
    0) 기능 
        => 테이블의 데이터 전체를 가져오기
        => 테이블의 데이터 일부분을 가져오기(페이지 단위로 가져오기)
        => 기본키를 이용해서 데이터 1개 가져오기
        => 데이터 삽입, 삭제, 갱신
        => 파일 업로드와 다운로드
        
        => 가장 최근에 데이터를 수정한 시간을 기록하고 조회
            => 서버와 클라이언트 사이의 데이터 교환
            - 접속할 때 마다 서버의 데이터를 가져와서 출력
            - 서버의 데이터를 클라이언트에 저장하고 접속할 때마다 서버의 데이터와 클라이언트의 데이터를 비교해서 수정이 발생했을 때만 업데이트
                -> 서버의 데이터와 클라이언트 데이터를 비교할 수 있어야 된다.
                -> 가장 쉬운 방법은 양쪽에서 수정한 시간을 기록한 후 클라이언트 수정 시간이 서버의 수정 시간보다 이전이면 업데이트를 수행한다.
         
    1) 샘플 데이터 생성 (DB 스크립트에서 실행)

        # 테이블 생성
        CREATE TABLE goods(
        itemid int,
        itemname VARCHAR(100), 
        price int,
        description VARCHAR(200), 
        pictureurl VARCHAR(100),
        updatedate varchar(20),
        PRIMARY KEY (itemid)
        )engine=InnoDB DEFAULT CHARSET=utf8;

        insert into goods values(1, '레몬', 500,'비타민 C가 풍부한 쓴귤', 'lemon.jpg', '2020-08-01');
        insert into goods values(2, '오렌지', 1500, '비타민 C가 풍부한 당귤', 'orange.jpg', '2020-08-01');
        insert into goods values(3, '키위', 2000, '비타민 C가 풍부한 다래', 'kiwi.jpg', '2020-08-01');
        insert into goods values(4, '포도', 1000, '항상화 성분과 당분이 높고 무기물이 많은 과일', 'grape.jpg', '2020-08-01'); 
        insert into goods values(5, '딸기', 2000, '수분함량이 높은 과일', 'strawberry.jpg', '2020-08-01');
        insert into goods values(6, '무화과', 300, '칼슘, 섬유질 및 항산화 물질을 많이 함유된 식물', 'fig.jpg', '2020-08-01');
        insert into goods values(7, '레몬', 500,'비타민 C가 풍부한 쓴귤', 'lemon.jpg', '2020-08-01');
        insert into goods values(8, '오렌지', 1500, '비타민 C가 풍부한 당귤', 'orange.jpg', '2020-08-01');
        insert into goods values(9, '키위', 2000, '비타민 C가 풍부한 다래', 'kiwi.jpg', '2020-08-01');
        insert into goods values(10, '포도', 1000, '항상화 성분과 당분이 높고 무기물이 많은 과일', 'grape.jpg', '2020-08-01'); 
        insert into goods values(11, '딸기', 2000, '수분함량이 높은 과일', 'strawberry.jpg', '2020-08-01');
        insert into goods values(12, '무화과', 300, '칼슘, 섬유질 및 항산화 물질을 많이 함유된 식물', 'fig.jpg', '2020-08-01');
        insert into goods values(13, '레몬', 500,'비타민 C가 풍부한 쓴귤', 'lemon.jpg', '2020-08-01');
        insert into goods values(14, '오렌지', 1500, '비타민 C가 풍부한 당귤', 'orange.jpg', '2020-08-01');
        insert into goods values(15, '키위', 2000, '비타민 C가 풍부한 다래', 'kiwi.jpg', '2020-08-01');
        insert into goods values(16, '포도', 1000, '항상화 성분과 당분이 높고 무기물이 많은 과일', 'grape.jpg', '2020-08-01'); 
        insert into goods values(17, '딸기', 2000, '수분함량이 높은 과일', 'strawberry.jpg', '2020-08-01');
        insert into goods values(18, '무화과', 300, '칼슘, 섬유질 및 항산화 물질을 많이 함유된 식물', 'fig.jpg', '2020-08-01');
        insert into goods values(19, '딸기', 2000, '수분함량이 높은 과일', 'strawberry.jpg', '2020-08-01');
        insert into goods values(20, '무화과', 300, '칼슘, 섬유질 및 항산화 물질을 많이 함유된 식물', 'fig.jpg', '2020-08-01');
        insert into goods values(21, '레몬', 500,'비타민 C가 풍부한 쓴귤', 'lemon.jpg', '2020-08-01');
        insert into goods values(22, '오렌지', 1500, '비타민 C가 풍부한 당귤', 'orange.jpg', '2020-08-01');
        insert into goods values(23, '키위', 2000, '비타민 C가 풍부한 다래', 'kiwi.jpg', '2020-08-01');
        insert into goods values(24, '포도', 1000, '항상화 성분과 당분이 높고 무기물이 많은 과일', 'grape.jpg', '2020-08-01'); 
        insert into goods values(25, '딸기', 2000, '수분함량이 높은 과일', 'strawberry.jpg', '2020-08-01');
        insert into goods values(26, '무화과', 300, '칼슘, 섬유질 및 항산화 물질을 많이 함유된 식물', 'fig.jpg', '2020-08-01');
        insert into goods values(27, '레몬', 500,'비타민 C가 풍부한 쓴귤', 'lemon.jpg', '2020-08-01');
        insert into goods values(28, '오렌지', 1500, '비타민 C가 풍부한 당귤', 'orange.jpg', '2020-08-01');
        insert into goods values(29, '키위', 2000, '비타민 C가 풍부한 다래', 'kiwi.jpg', '2020-08-01');
        insert into goods values(30, '포도', 1000, '항상화 성분과 당분이 높고 무기물이 많은 과일', 'grape.jpg', '2020-08-01'); 

        commit;
        
        # 데이터 확인
        select * from goods;

    2) 필요한 모듈 설치
        => express : 웹 서버 모듈
        => morgan : 로그 기록을 위한 모듈
        => file-stream-rotator : 로그를 파일에 기록하기 위한 모듈
        => multer : 파일 업로드 처리를 위한 모듈
        => mysql : mysql이나 mariadb를 사용하기 위한 모듈
        => cookie-parser : 쿠키를 사용하기 위한 모듈
        => express-session : 세션을 사용하기 위한 모듈
        => express-mysql-session : 세션을 mysql이나 mariadb에 저장하기 위한 모듈
        => dotenv :.env 파일의 내용을 process.env로 저장해서 사용하기 위한 모듈
        => compresstion : 서버가 처리한 결과를 압축해서 클라이언트에게 전송하기 위한 모듈

    3) 개발 모드로 설치
        => npm install --save=dev nodemon
        => nodemon : 소스코드르르 수정하면 자동으로 재시작할 수 있도록 해주모듈
        => package.json파일의 Script 부분에 "start":"nodemon.app"을 추가 -> npm start 명령을 사용하면 nodemon app 이라는 명령이 수행되어
           entry point

    4) 서버의 데이터 업데이트 시간을 기록할 update.txt 파일을 프로젝트에 만든다
    
    5)프로젝트에 .env 파일을 만들고 필요한 속성을 정의

    6) Index.js 파일에 기본 설정 코드를 작성

        const express = require('express');
        const morgan = require('morgan');
        const compression = require('compression');
        const path = require('path');
        const mysql = require('mysql');
        const cookieParser = require('cookie-parser');
        const session = require('express-session');
        const multer = require('multer');
        const dotenv = require('dotenv');

        //설정 파일의 내용 가져오기
        dotenv.config();

        //서버 설정
        const app = express();
        app.set('port', process.env.PORT || 9000);

        //로그를 매일 기록하기 위한 설정
        let FileStreamRotator = require('file-stream-rotator');
        let fs = require('fs');

        //로그를 기록할 디렉토리 경로 생성
        let logDirectory = path.join(__dirname, 'log');

        //디렉토리가 없으면 생성
        fs.existsSync(logDirectory) || fs.mkdirSync(logDirectory);

        //로그 파일 옵션을 설정
        let accessLogStream = FileStreamRotator.getStream({
            date_format:'YYYYMMDD',
            filename:path.join(logDirectory, 'access-%DATE%.log'),
            frequency:'daliy',
            verbose:false
        });
        //로그 기록 설정
        app.use(morgan('combined', {stream:accessLogStream}));

        //압축해서 전송하는 옵션 설정
        app.use(compression());

        //POST 방식의 파라미터 읽을 수 있도록 설정
        let bodyParser = require('body-parser');
        app.use(bodyParser.json());
        app.use(bodyParser.urlencoded({
            extended:true
        }));

        //세션을 데이터베이스에 저장하는 작업

        //데이터베이스 접속 정보
        let options = {
            host:'127.0.0.1',
            port:3306,
            user:'root',
            password:'wnddkd',
            database:'adam'
        };
        //세션을 저장하기 위한 MySQL 데이터베이스 저장소 생성
        const MariaDBStore = require('express-mysql-session')(session);
        //세션 설정
        app.use(session({
            secret:process.env.COOKIE_SECRET,
            resave:false,
            saveUninitialized:true,
            store:new MariaDBStore(options)
        }));

        //파일 업로드 설정
        const upload = multer({
            storage:multer.diskStorage({
                destination(req, file, done){
                    done(null, 'public/img');
                },
                filename(req, file, done){
                    const ext = path.extname(file.originalname);
                    done(null, path.basename(file.originalname, ext) +
                        Date.now() + ext);
                }
            }),
            limits:{fileSize: 10*1024*1024}
        });

        //정적 파일의 경로를 설정
        app.use('/', express.static('public'));

        //파일 다운로드를 위한 모듈
        let util = require('util');
        let mime = require('mime');

        //데이터베이스 연결
        let connection = mysql.createConnection(options);
        connection.connect((error) => {
            if(error){
                console.log(error);
                throw error;
            }
        })


        //에러 발생시 처리
        app.use((err, req, res, next)=>{
            console.log(err);
            res.status(500).send(err.message);
        });

        //서버 구동
        app.listen(app.get('port'), () => {
            console.log(app.get('port'), '번 포트에서 대기 중');
        });

    7) 서버 구동해서 테스트

    8) 프로젝트에 public 디렉토리 생성

    9) 샘플 데이터의 이미지를 다운로드 받아서 public 디렉토리에 img 디렉토리로 복사 https://ggangpae1.tistory.com/377

    10) 메인 화면 출력 : 서버가 데이터만 리턴하고자 하는 경우에는 이 설정은 필요없음 -> public 디렉토리에 메인 화면으로 사용할 html을 생성하고 작성 - index.html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Node - MariaDB</title>
            <link rel="stylesheet" href="/css/common.css" />
        </head>
        <body>
            <h1>Maria DB</h1>
        </body>
        </html>

    11)public 디렉토리에 css 디렉토리를 생성하고 common.css 파일을 만들고 작성
        h1{
            color:red;
        }

        a{
            text-decoration: none;
        }

    12)Index.js 파일에 기본 요청을 처리하는 코드를 추가

        //기본 요청을 처리
        app.get('/', (req, res) => {
            res.sendFile(path.join(__dirname, 'index.html'));
        });

    13) 서버를 구동하고 브라우저에서 localhost:9000 을 입력해서 확인

    14) 데이터베이스에서 아래 SQL을 실행해서 세션이 만들어지고 있는지 확인
        SELECT *FROM sessions;

    15) 프로젝트 내의 log 디렉토리 안의 로그 파일을 확인

    16) 데이터 전체 가져오기 -> URL: item/all
        - 

    17) Index.js 파일에 추가

        //데이터 전체 가져오기 처리
        app.get('/item/all', (req, res) => {
            //템플릿 엔진: res.render(파일 경로, 데이터)
            //템플릿 엔진에 넘겨주는 데이터는 프로그래밍 언어의 데이터
            
            //JSON 출력: res.json(데이터)
            //json 문자열의 형태로 데이터를 제공
            //Front End 에서 데이터를 수신해서 출력
            
            //2개 이상의 데이터를 조회할 때는 정렬은 필수
            connection.query("select * from goods order by itemid desc", 
                (err, results, fields)=>{
                    if(err){
                        //에러가 발생한 경우
                        //에러가 발생했다고 데이터를 전송하지 않으면 안됨
                        res.json({'result':false})

                    }else{
                        //정상 응답을 한 경우
                        res.json({'result':true, 'list':results});
                    }
            });
        });

    18) 서버를 실행하고 브라우저에 localhost:9000/item/all 을 입력하고 데이터가 출력되는지 확인

    19) index.html 파일에 전체 데이터 가져오기를 위한 코드를 추가 => body 태그에 이벤트를 위한 DOM을 작성
       <script>
            window.addEventListener('load', (e) => {
                // 이벤트 적용할 DOM 찾아오기
                let allbtn = document.getElementById("allbtn");

                // allbtn 클릭이벤트 처리
                allbtn.addEventListener('click', (e) => {
                    // ajax로 데이터 가져오기
                    let request = new XMLHttpRequest();

                    // 요청 생성
                    request.open('GET', "/item/all");

                    // 요청
                    request.send('');

                    // 데이터가 전송된 경우 처림
                    request.addEventListener('load', () => {
                        // JSON 문자열 출력 TEST alert(request.responseText); 출력하기 위해서 JSON 문자열을 JS 객체로 변환
                        let data = JSON.parse(request.responseText);

                        // 데이터 가져오기에 성공한 경우
                        if (data.result == true) {
                            content.innerHTML = "<div align = 'center' class = 'body'>";
                            content.innerHTML += "<h2>상품목록<h2/>";
                            content.innerHTML += "<table border = '1'>";

                            content.innerHTML += "<tr class='header'>";
                            content.innerHTML += "<th align 'center' width = '80'>ID</th>"
                            content.innerHTML += "<th align 'center' width = '320'>이름</th>"
                            content.innerHTML += "<th align 'center' width = '100'>가격</th>"
                            content.innerHTML += "</tr>";

                            let dataAr = data.list;
                            for (let item of dataAr) { // 요즘은 for in 문보다 for of를 사용해서 배열을 순회 한다.
                                content.innerHTML += "<tr class='record'>";

                                content.innerHTML += "<td align='center'>" + item.itemid + "</td>"
                                content.innerHTML += "<td align='center'>" + item.itemname + "</td>"
                                content.innerHTML += "<td align='center'>" + item.price + "</td>"

                                content.innerHTML += "</tr>";
                            }

                            content.innerHTML += "</table>";
                            content.innerHTML += "</div>";
                        } else {
                            content.innerHTML = "데이터 가져오기 실패"
                        }
                    });
                });
            });
        </script>

    20) 데이터 일부분 가져오기
        데이터의 일부분 가져오기를 처리할 때는 일반적으로 2개의 데이터가 필요.
        하나는 페이지 번호는 시작하는 데이터의 번호
        시작하는 데이터 번호를 주는 경우는 데이터의 개수가 고정인 경우가 많습니다.
        다른 하나는 한 페이지에 출력할 데이터 개수

        =>URL 확인
        한겨레 신문사의 경우는 page 에 페이지 번호를 전달
        https://search.hani.co.kr/search/newslist?searchword=%EC%9D%B4%ED%83%9C%EC%9B%90&startdate=1988.01.01&enddate=2022.11.24&page=2&sort=desc

        https://search.hani.co.kr/search/newslist?searchword=%EC%9D%B4%ED%83%9C%EC%9B%90&startdate=1988.01.01&enddate=2022.11.24&page=3&sort=desc

        동아일보는 p 가 데이터의 시작 번호
        https://www.donga.com/news/search?p=16&query=%EC%9D%B4%ED%83%9C%EC%9B%90&check_news=91&more=1&sorting=1&search_date=1&v1=&v2=

        https://www.donga.com/news/search?p=31&query=%EC%9D%B4%ED%83%9C%EC%9B%90&check_news=91&more=1&sorting=1&search_date=1&v1=&v2=

        => 페이지 번호를 전달하는 것으로 결정하고 데이터의 개수는 5개로 고정 페이지, 번호를 전달하지 않으면 1페이지의 데이터를 전송하고 그 이외의 경우는 페이지 번호에 해당하는 데이터를 전달

        => get 방식에서의 서버로의 데이터 전달

        -> 전달하고자 하는 데이터가 1개 인 경우
            - 파라미터로 전달: URL?이름=값
            - URL에 전달: URL/값 - 최근에는 이 방식을 선호

        -> 전달하고자 하는 데이터가 2개 이상인 경우는 파라미터 형태로 전달
            - URL?이름=값&이름=값...

            - 파라미터 읽기: req.query.파라미터이름

            - URL을 읽기: req.params.변수명

            =>URL을 결정 - /item/list

        => Node.js에서 SQL을 이용해서 Select 구문을 실행했을 때의 결과는 무조건 배열이다.
        => Select 구문을 수행하게 되면 몇개의 행이 나올지 몇개의 열이 나올지 알 수 없다
            -> [{컬럼이름: 값, 컬럼이름 : 값, ...}, {..}, {..}, ...] 과 같은 구조를 만들어 두고 채워 나간다.
            -> select count(*) from goods; 를 불러온 connection.query 문의 데이터 값은 [{count(*): 30}]과 같이 담겨있게 된다.
            -> result[0].count(*)와 같이 읽어올 수 있지만 select count(*) cnt from goods; 와 같이 별명을 붙여서 읽어내는 것을 권장

        -> Index.JS
        // 데이터 일부분 가져오기 - URL:/item/list , 파라미터는 pageno 1개 인데 없으면 1로 설정
        app.get('/item/list', (req, res) => {
            // 파라미터 읽어오기
            let pageno = req.query.pageno;

            if (pageno == undefined) {
                pageno = 1;
            }
            // http://localhost:9000/item/list?pageno=2 브라우저에서 강제로 매개변수 넘겨주는 방식 넘어오는지
            // console로 확인
            //console.log(pageno);

            // item 테이블에서 itemid를 가지고 내림차순 정렬해서 페이지 단위로 데이터 가져오기 select * feom item order by
            // itemid desc limit 시작번호, 5 시작번호 = (pageno-1)*5 파라미터는 무조건 문자열이므로 산술연산이 필요하다면
            // 숫자로 형변환 해야한다. 성공여부
            let sucOrFail = true;
            // 성공했을 때 데이터를 저장
            let list;
            // 데이터 목록 가져오기
            connection.query(
                "select * from goods order by itemid desc limit ? , 5",
                [(parseInt(pageno) - 1) * 5],
                (err, result, fields) => {
                    if (err) {
                        console.log(err);
                        sucOrFail = false;
                    } else {
                        list = result;
                    }
                }
            );

            // 테이블의 전체 데이터 개수를 가져오기
            -> Index.JS
            let dataCnt = 0;
            connection.query("select count(*) cnt from goods;", (err, result, fields) => {
                if (err) {
                    // 에러 발생시 실행할 구문
                    console.log(err);
                } else {
                    // 쿼리 정상 실행 되었을 때 실행할 구문
                    dataCnt = result[0].cnt;
                }
                // 응답 생성해서 전송
                if (sucOrFail === false) {
                    res.json({"result": false});
                } else {
                    res.json({"result": true, "list": list, "count": dataCnt});
                }
            });

        });

        -> index.html 출력 참고
        let listbtn = document.getElementById("listbtn");
                let pageno = 1;
                listbtn.addEventListener("click", (e) => {
                    let request = new XMLHttpRequest();
                    request.open('GET', '/item/list?pageno=' + pageno);
                    request.send('');
                    request.addEventListener("load", () => {
                        // 출력 영역 초기화
                        content.innerHTML = '';
                        // 데이터를 파싱
                        let data = JSON.parse(request.responseText);
                        if (data.result === true) {
                            // 데이터 개수와 목록을 가져온다.
                            let count = data.count;
                            let list = data.list;

                            // 출력 내용 만들기
                            let display = "<div align='center' class='body'>";
                            display += "<h2>상품목록</h2>";
                            display += "<table border = '1' id='tbldata'>";

                            display += "<tr><td colspan='3' aligh='right'>";
                            display += "전체 데이터 개수 : " + count + "개</td> </tr>";

                            // 항목 헤더 출력
                            display += "<tr class='header'>";
                            display += "<th width='80'>ID</th>";
                            display += "<th width='320'>상품명</th>";
                            display += "<th width='100'>가격</th>";
                            display += "</tr>";

                            // 데이터 목록 출력
                            for (item of list) {
                                display += "<tr class = 'record'>";
                                display += "<td align = 'center'>" + item.itemid + "</td>";
                                // 상세보기를 위해서 제목에 item + 실제 itemid 를 추가해서 id를 생성
                                display += "<td align = 'left'>" + "<a href='#' id = 'item" + item.itemid +"'>" + item.itemname + "</a></td>";
                                display += "<td align = 'right'>" + item.price + "원 </td>";
                                display += "</tr>";
                            }

                            display += "</table></div>";

                            // 더보기 구현 현재 페이지가 마지막 페이지가 아닌 경우만 출력
                            if ((pageno - 1) * 5 < count) {
                                display += "<table align='center' width='500' id='tblbtn'>";
                                display += "<tr><td align='center' colspan='3'>";
                                display += "<span id='addbtn'><a href='#'>더보기</a></span></td>";
                                display += "</tr></table>";
                            }
                            content.innerHTML = display;

                            let addbtn = document.getElementById("addbtn");
                            /* addbtn.addEventListener('clink', (e) => { });
                                NullPointerException 에러 발생할 가능성이 높은 상황이다.
                                addbtn이 무조건 있는 것이 아니라 조건(페이지 생성 개수 5개 보다 많은 경우)
                                특히 코딩테스 같은 경우에도 try catch 같은 것이나 예외 방지를 위한 노력을 해야한다.
                            */
                            if (addbtn != undefined) {
                                addbtn.addEventListener('click', (e) => {
                                    pageno += 1;
                                    let request = new XMLHttpRequest();
                                    request.open('GET', 'item/list?pageno=' + pageno);
                                    request.send('');

                                    // 전체 데이터 개수보다 더 많이 출력하면 더보기 영역을 삭제하도록 함
                                    if ((pageno) * 5 > data.count) {
                                        pageno -= 1;
                                        document
                                            .getElementById("tblbtn")
                                            .remove();
                                    }

                                    // 데이터를 가져오면 출력하도록
                                    request.addEventListener('load', () => {
                                        let data = JSON.parse(request.responseText);
                                        let list = data.list;

                                        // 데이터 테이블 출력
                                        const table = document.getElementById('tbldata');
                                        let display = "";
                                        for (item of list) {
                                            display += "<tr class = 'record'>";
                                            display += "<td align = 'center'>" + item.itemid + "</td>";
                                            // 상세보기를 위해서 제목에 item + 실제 itemid 를 추가해서 id를 생성
                                            display += "<td align = 'left'>" + "<a href='#' id = 'item" + item.itemid +"'>" + item.itemname + "</a></td>";
                                            display += "<td align = 'right'>" + item.price + "원 </td>";
                                            display += "</tr>";
                                        }
                                        table.innerHTML += display;
                                    })
                                });
                            }

                        } else {
                            content.innerHTML = '<p> 데이터를 가져오는데 실패 </p>';
                        }
                    });
                });


    21) 데이터 상세보기
        => 데이터 한 개의 정보를 전부 가져와서 출력 하는 것
        => 테이블에서 데이터 1개를 가져오는 방법은 기본키나 unique 속성을 이용한 조회만 가능하다. (unique는 null 조회시 여러개가 나올 수 있다.)
        => 기본키나 unique속성의 값을 받아서 서버에서 처리
        => itemid를 URL에 포함시켜 데이터를 받는 방법

        -> Index.JS
        // 상세보기 처리를 위한 코드
        app.get('/item/detail/:itemid', (req, res) => {
            // 파라미터 읽기
            let itemid = req.params.itemid;

            // itemid를 이용해서 1개의 데이터를 찾아오는 SQL을 실생
            connection.query("select * from goods where itemid = ?", [itemid], (err, result, fields) => {
                if(err){
                    console.log(err);
                    res.json({"result" : false});
                }else{
                    res.json({"result" : true, "item":result[0]});
                }
            });
        });
        
        => 테스트는 localhost:9000/item/detail/번호

        -> index.html 출력
        - 테이블에서 상품목록을 보여주는 코드중 이름을 출력하는 부분을 아래와 같이 변경

        // 상세보기를 위해서 item이름이 출력되는 요소에 item + 실제 itemid 를 추가해서 id를 생성
        display += "<td align = 'left'>" + "<a href='#' id = 'item" + item.itemid +"'>" + item.itemname + "</a></td>";

        // item name을 눌렀을 때 수행할 코드
        // 링크 하나하나 이벤트 처리하는 것은 자원낭비로 부모에 이벤트 처리 코드 작성
        content.addEventListener('click', (e) => {
    
            // 클릭한 대상의 id가 item으로 시작하는 경우에만 동작

            if(e.target.id.startsWith('item')){
                // 클릭한 대상의 아이디에서 item을 제외한 부분 -> 실제 데이터의 itemid key값이 나오는지
                let itemid = e.target.id.substring(4).trim();
                //alert(itemid);
                let request = new XMLHttpRequest();
                request.open('GET', '/item/detail/' + itemid);
                request.send('');
                request.addEventListener('load', () => {
                    let data = JSON.parse(request.responseText);
                    if(data.result == true){
                        // 데이터 가져오기
                        let item = data.item

                        // 출력 내용 생성
                        let display = "<div align = 'center' class='body'>";
                        display += "<h2>상세보기</h2>";
                        display += "<table>";
                        display += "<tr><td><img src='/img/" + item.pictureurl + "'/></td>";

                        display += "<td align = 'center'><table>";
                        display += "<tr height='50'><td width='80'>상품명</td>";
                        display += "<td width='160'>" + item.itemname + "</td>";
                        display += "<tr height='50'><td width='80'>가격</td>";
                        display += "<td width='160'>" + item.price + "원</td>";
                        display += "<tr height='50'><td width='80'>비고</td>";
                        display += "<td width='160'>" + item.description + "</td><tr>";
                                
                        display += "</table></td></tr></table>"

                        // SPA -> single 페이지 구현하는 방식
                        content.innerHTML = display;
                    }
                });
            }
        });

    22) 첨부파일(이미지) 다운로드
        => 웹 브라우저에서는 파일에 링크가 걸려있으면 자신이 출력할 수 있는 파일은 출력하고 출력할 수 없는 파일은 다운로드를 수행한다.
        
        -> index.html의 파일 출력하는 부분을 수정한다.
        => display += "<tr><td> <a href='/img/" + item.pictureurl + "'>" 
                + "<img src='/img/" + item.pictureurl + "'/></td>";

        -> Index.js
        app.get('/img/:pictureurl', (req, res) => {
            let pictureurl = req.params.pictureurl;

            // 이미지 파일의 절대경로를 줘야 한다.
            let file = "C:\VsCode\NodePrac\NodePracDay4\public\img" + "/" + pictureurl;
            console.log(__dirname);

            // 파일 이름을 가지고 타입을 생성
            let mimetype = mime.lookup(pictureurl);
            res.setHeader('Content-disposition', 'attachment; filename=' + pictureurl);
            res.setHeader('Content-type', mimetype);

            // 파일의 내용을 읽어서 res에 전송
            let filestream = fs.createReadStream(file);
            filestream.pipe(res);
        });

    23) 데이터 삽입
        => 데이터 삽입은 삽입화면을 먼저 출력하고 데이터를 입력받은 후 데이터를 서버에게 전송하면 처리한다.
        => 데이터 삽입은 GET, POST 방식으로 처리한다.
        => POST 방식은 화면을 만들지 않고 웹 브라우저에서는 테스트가 불가능하기 때문에 서버에 post 방식 요청을 만들고 테스트가 필요할 때는
           프로그램을 설치해서 진행한다.
        => 위 방법을 사용하면 index.html 처럼 출력화면을 구현할 필요가 없었지만 진행한 이유는 SPA를 직접 구현하는데 목적이 있었다.

        -> App.js
        => 어떤 데이터를 받을 것인지 결정.

        => 중복되지 않아야 하는 PK 중 ID와 같이 직접 입력받는 값(중복 확인 필수)이 아닌 auto_increment를 이용한 값들은 n번을 사용하고 삭제되어도
           다음 값은 무조건 n+1번이 되므로 다시 n번을 사용하기 위해서는 가장큰 pk 값 + 1해야 한다.

        => 파일 업로드시 파일의 실제 이름이 아닌 UDID(인터넷에서 이미지 파일 다운 받을 때 나오는 복잡한 이름들)를 사용한다.(겹칠 확률이 매우적음.)

        => itemid : 가장 큰 itemid를 찾아서 +1 
        => itemname, price, decoration, pictureurl(파일)은 직접 입력
        => updatedate는 현재 날짜를 문자열로 입력 
        
        => 삽입/삭제/갱신 작업이 발생하면 updatedate.txt 파일에 발생한 시간을 기록.(현재 데이터가 업데이트 된 시간을 알기 위해서)4
        
        => App.js 파일에 현재 날짜를 문자열로 반환하는 함수와 현재 날짜 및 시간을 문자열로 반환하는 함수작성

            -> P.S. 1월부터 12월까지의 날의 숫자를 배열로 생성될때
               [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 과 같이 생성되어 있는데, 
               [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 처럼 주어서 index 0을 버림으로써 코딩의 효율을 높이는 것을 추천한다.
               CPU나 메모리는 웬만하면 double 단위로 계산하거나 파일의 단위는 word 이므로 최소 512바이트 이상으로 만들어지기 때문에 
               작은 차이를 줄이는 행동은 오히려 해가 될 수 있다.

        // 현재 날짜를 문자열로 반환하는 함수
        // 요즘 등장하는 JS 라이브러리 샘플 예제는 특별한 경우가 아니면 fucntion을 사용하지 않는다.
        const getDate = () => {
            let date = new Date();

            let year = date.getFullYear();

            // 월은 +1을 해야 우리가 사용하는 월이 된다.
            let month = date.getMonth() + 1;
            let day = date.getDate();

            month = month >= 10 ? month : '0' + month;
            day = day >= 10 ? day : '0' + day;
            
            return year + "-" + month + "-" + day;
        }

        // 날짜와 시간을 반환하는 함수
        const getTime = () => {
            let date = new Date();
            let hour = date.getHours();
            let minute = date.getMinutes();
            let second = date.getSeconds();

            hour = hour >= 10 ? hour : '0' + hour;
            minute = minute >= 10 ? minute : '0' + minute;
            second = second >= 10 ? second : '0' + second;

            return getDate() + " " + hour + ":"  + minute + ":"  + second
        }


        //데이터 삽입을 처리해주는 함수
        app.post('/item/insert', upload.single('pictureurl'), 
            (req, res) => {
            //파라미터 읽어오기
            const itemname = req.body.itemname;
            const description = req.body.description;
            const price = req.body.price;

            //파일 이름 - 업로드하는 파일이 없으면 default.png
            let pictureurl;
            if(req.file){
                pictureurl = req.file.filename
            }else{
                pictureurl = 'default.jpg';
            }

            //가장 큰 itemid 찾기
            connection.query("select max(itemid) maxid from goods",
            [], (err, results, fields) => {
                let itemid;
                //최대값이 있으면 + 1 하고 없으면 1로 설정
                if(results.length > 0 ){
                    itemid = results[0].maxid + 1;
                }else{
                    itemid = 1;
                }

                //데이터 삽입
                connection.query("insert into goods(" + 
                    "itemid, itemname, price, description," 
                    + "pictureurl, updatedate) values(?, ?, ?, ?, ?, ?)",
                    [itemid, itemname, price, description, pictureurl,
                    getDate()], (err, results, fields) => {
                    if(err){
                        console.log(err);
                        res.json({"result":false});
                    }else{
                        //현재 날짜 및 시간을 update.txt에 기록
                        const writeStream = fs.createWriteStream('./update.txt');
                        writeStream.write(getTime());
                        writeStream.end();

                        res.json({"result":true});
                    }
                })
            });
        })

        => postman 으로 확인 후 뷰 작성

        let insertbtn = document.getElementById("insertbtn");
                insertbtn.addEventListener('click', (e) => {
                    // 삽입화면 출력
                    content.innerHTML = '';
                    let html = 
                       `
                        <div>
                            <p></p>
                            <form id = 'insertform' enctype = 'multipart/form-data' method = 'post'>
                                아이템 이름<input type = 'text' name='itemname' id ='itemname'/></br>
                                가격<input type = 'text' name='price' id = 'price'/></br>
                                설명<input type = 'text' name='description' id = 'description'/></br>  
                                이미지<input type='file' name='pictureurl' id = 'pictureurl'/></br>
                                <input type='submit' value='삽입'/>
                            </from>
                        </div>
                        `
                        content.innerHTML = html;

                        // from 안에서 삽입 버튼을 눌렀을 때 처리
                        let f = document.getElementById("insertbtn");
                        if(f != undefined){
                            f.addEventListener('submit', (e) => {
                                // 기본 이벤트 제거
                                e.preventDefault(); 
                                // form 데이터 찾아오기
                                const formData = new FormData(
                                    document.getElementById('insertbtn')
                                );

                                // form 데이터
                                let request = new XMLHttpRequest();
                                request.open("POST", "/item/insert", true);
                                request(formData);
                                request.addEventListener('load', () => {
                                    let data = JSON.parse(request.responseText);
                                    if(data.result){
                                        document.getElementById("listbtn").click();
                                    } else {
                                        alert("삽입실패")
                                    }
                                })
                            });
                        }
                });

                ....-> <body>
                <input type="button" value="데이터 삽입" id ="insertbtn"/> 추가
    
    24) 데이터 삭제
        => 기본키를 매개변수로 받아서 삭제한다.
        => 삭제는 GET이나 POST 둘 다 가능하다.

        -> App.js
        => itemid를 받아 삭제하는 것 구현

    app.post("/item/delete", (req, res) => {
        // post 방식으로 전송된 데이터 읽기
        let itemid = req.body.itemid;
        connection.query("delete from goods where itemid=?", [itemid], (err, result, fields) => {
            if(err){
                console.log(err);
                res.json({"result":false});
            } else {
                // 현재 날짜 및 시간을 update.txt에 기록
                const writeStream = fs.createWriteStream('./update.txt');
                writeStream.write(getTime());
                writeStream.end();
                res.json({"result":true});
            }
        });
    });
    => POSTMAN으로 확인

    -> index.html
    => 상세보기 출력 부분을 수정해서 삭제를 위한 DOM을 추가
     // 삭제를 위한 DOM을 추가
     display += "<tr><td colspan='2' align='center' width='240'> <a href='#' id='deletebtn'>데이터 삭제</a></td></tr>"

    => 삭제 요청을 보낼 스크립트를 상새보기 코드 아래부분에 추가
    let deletebtn = document.getElementById("deletebtn");
    if(deletebtn != undefined) {
        deletebtn.addEventListener('click', (e) => {
        // form이 없는 경우의 POST 방식 파라미터 만들기
            let params = 'itemid' + item.itemid;

            let request = new XMLHttpRequest();
            request.open('POST', '/item/delete');
                                        
            // from이 아닌 경우는 form 형식으로 인코딩
            request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
            request.send(params);
            request.addEventListener('load', () => {
                let data = JSON.parse(request.responseText)
                if(data.result){
                    document.getElementById("listbtn").click();
                        alert("삭제 성공");
                } else {
                    alert("삭제 실패");
                }
            });
        });
    }

    25) 데이터 수정
        => 현재 데이터를 수정할 수 있도록 화면에 출력하고 데이터를 입력받아서 수정한다.
        => 텍스트는 입력받은 내용을 수정하면 되는데 이전 내용을 화면에 출력한 상태에서 내용을 고치지 않았어도 set이나 value값으로
           수정/출력 되는데 file은 수정

    -> update.html
    => 수정화면을 위한 html파일 생성(이번엔 컴포넌트 처럼 나눠서 생성한다. /public/update.html)
    <form method="post" id="updateform" 
        enctype="multipart/form-data">
        아이템 아이디:<input type="text" name="itemid" id="itemid"/>
        <br/>
        아이템 이름:<input type="text" name="itemname" id="itemname"/>
        <br/>
        아이템 가격:<input type="text" name="price" id="price"/>
        <br/>
        설명:<input type="text" name="description" id="description"/>
        <br/>
        새로운 이미지:<input type="file" name="pictureurl" />
        <br/>
        이전 이미지<img width="100" height="100" id="picture">
        <br/>
        <!-- hidden 은 화면에 출력되지는 않지만 가지고 있어야 하는
        데이터가 있을 때 사용-->
        <input type="hidden" name="oldpictureurl" id="oldpictureurl"/>
        <br />
        <input type="submit" value="수정" />
    </form>

    -> Index.js
    => 수정의 get요청이 오면 처리할 함수 작성
    app.get('/item/update', (req, res) => {
        // public 디렉터리의 update.html을 읽어내서 반환
        fs.readFile('./public/update.html' , (err, data) => {
            res.end(data);
        })
    })

    -> index.html
    => index.html 에서 수정화면(update.html)으로 이동하기 위한 코드 작성
    =>상세보기를 출력하는 부분에 데이터 수정 DOM을 추가(삭제를 추가한 부분의 위나 아래에 추가)
    //수정을 위한 DOM을 추가
    display += "<tr>" + "<td colspan='2' align='center' width='240'>"+ "<a href='#' id='updatebtn'>데이터 수정</a>" + "</td></tr>";
    
    =>수정 버튼을 눌렀을 때 처리를 위한 스크립트 코드를 추가
        
        
 

